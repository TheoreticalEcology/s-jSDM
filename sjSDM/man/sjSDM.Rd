% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sjSDM.R
\name{sjSDM}
\alias{sjSDM}
\title{sjSDM}
\usage{
sjSDM(Y = NULL, env = NULL, biotic = bioticStruct(), spatial = NULL,
  family = stats::binomial("probit"), iter = 100L, step_size = NULL,
  learning_rate = 0.01, se = FALSE, sampling = 1000L, parallel = 0L,
  control = sjSDMControl(), device = "cpu", dtype = "float32")
}
\arguments{
\item{Y}{matrix of species occurences/responses in range [0,1]}

\item{env}{matrix of environmental predictors, object of type \code{\link{linear}} or \code{\link{DNN}}}

\item{biotic}{defines biotic (species-species associations) structure, object of type \code{\link{bioticStruct}}}

\item{spatial}{defines spatial structure, object of type \code{\link{linear}} or \code{\link{DNN}}}

\item{family}{error distribution with link function, see details for supported family functions}

\item{iter}{number of fitting iterations}

\item{step_size}{batch size for stochastic gradient descent, if \code{NULL} then step_size is set to: \code{step_size = 0.1*nrow(X)}}

\item{learning_rate}{learning rate for Adamax optimizer}

\item{se}{calculate standard errors for environmental coefficients}

\item{sampling}{number of sampling steps for Monte Carlo integreation}

\item{parallel}{number of cpu cores for the data loader, only necessary for large datasets}

\item{control}{control parameters for optimizer, see \code{\link{sjSDMControl}}}

\item{device}{which device to be used, "cpu" or "gpu"}

\item{dtype}{which data type, most GPUs support only 32 bit floats.}
}
\description{
fast and accurate joint species model
}
\details{
The function fits a multivariate probit model via Monte-Carlo integration (see Chen et al., 2018) of the joint likelihood for all species. See Pichler and Hartig, 2020 for benchmark results.

sjSDM depends on the anaconda python distribution and pytorch, which need to be installed before being able to use the sjSDM function. 
See \code{\link{install_sjSDM}}, \code{vignette("Dependencies", package = "sjSDM")}
}
\section{Family}{

Currently supported distributions and link functions:
\itemize{
\item \code{\link{binomial}}: \code{"probit"} or \code{"logit"}
\item \code{\link{poisson}}: \code{"log"} 
\item \code{\link{gaussian}}: \code{"identity"} 
}
}

\section{Installation}{

\code{\link{install_sjSDM}} should be theoretically able to install conda and pytorch automatically. If \code{\link{sjSDM}} still does not work after reloading RStudio, you can try to solve this in on your own with our trouble shooting guide \code{\link{installation_help}}.
If the trouble shooting guide did not help, please create an issue on \href{https://github.com/TheoreticalEcology/s-jSDM/issues}{issue tracker} with a copy of the \code{\link{install_diagnostic}} output as a quote.
}

\examples{
\donttest{
  
# Basic workflow:
## simulate community:
com = simulate_SDM(env = 3L, species = 7L, sites = 100L)

## fit model:
model = sjSDM(Y = com$response,env = com$env_weights, iter = 2L) 
# increase iter for your own data 

coef(model)
summary(model)
getCov(model)

## plot results
species=c("sp1","sp2","sp3","sp4","sp5","sp6","sp7")
group=c("mammal","bird","fish","fish","mammal","amphibian","amphibian")
group = data.frame(species=species,group=group)
plot(model,group=group)

## calculate post-hoc p-values:
p = getSe(model)
summary(p)

## or turn on the option in the sjSDM function:
model = sjSDM(Y = com$response, env = com$env_weights, se = TRUE, 
              family = binomial("probit"), 
              iter = 2L)
summary(model)

## fit model with interactions:
model = sjSDM(Y = com$response,
              env = linear(data = com$env_weights, formula = ~X1:X2 + X3), 
              se = TRUE,
              iter = 2L) # increase iter for your own data 
summary(model)

## without intercept:
model = sjSDM(Y = com$response,
              env = linear(data = com$env_weights, formula = ~0+X1:X2 + X3), 
              se = TRUE,
              iter = 2L) # increase iter for your own data 
summary(model)

## predict with model:
preds = predict(model, newdata = com$env_weights)


# With spatial terms:
## linear spatial model
XY = matrix(rnorm(200), 100, 2)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(XY, ~0+X1:X2),
              iter = 2L) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = XY)

## Using spatial eigenvectors as predictors to account 
## for spatial autocorrelation is a common approach:
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+., lambda = 0.1),
              iter = 2L) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)



## non-linear(deep neural network) model
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = DNN(SPV,hidden = c(5L, 5L), ~0+.),
              iter = 2L) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)


# Regularization
## lambda is the regularization strength
## alpha weights the lasso or ridge penalty:
## - alpha = 0 --> pure lasso
## - alpha = 1.0 --> pure ridge
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = linear(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              iter = 2L) # increase iter for your own data 
summary(model)
coef(model)
getCov(model)



# Anova 
com = simulate_SDM(env = 3L, species = 15L, sites = 200L)

XY = matrix(rnorm(400), 200, 2)
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+.), 
              iter = 2L) # increase iter for your own data 
result = anova(model, cv = 2L)
print(result)
plot(result)


# Deep neural network
## we can fit also a deep neural network instead of a linear model:
model = sjSDM(Y = com$response,
              env = DNN(com$env_weights, hidden = c(10L, 10L, 10L)),
              iter = 2L) # increase iter for your own data 
summary(model)
getCov(model)
pred = predict(model, newdata = com$env_weights)

## extract weights
weights = getWeights(model)

## we can also assign weights:
setWeights(model, weights)

## with regularization:
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = DNN(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              iter = 2L) # increase iter for your own data 
getCov(model)
getWeights(model)
}
}
\references{
Chen, D., Xue, Y., & Gomes, C. P. (2018). End-to-end learning for the deep multivariate probit model. arXiv preprint arXiv:1803.08591.

Pichler, M., and Hartig, F. (2020). A new method for faster and more accurate inference of species associations from novel community data. arXiv preprint arXiv:2003.05331.
}
\seealso{
\code{\link{sjSDM_cv}}, \code{\link{DNN}}, \code{\link{plot.sjSDM}}, \code{\link{print.sjSDM}}, \code{\link{predict.sjSDM}}, \code{\link{coef.sjSDM}}, \code{\link{summary.sjSDM}}, \code{\link{getCov}}, \code{\link{simulate.sjSDM}}, \code{\link{getSe}}, \code{\link{anova.sjSDM}}, \code{\link{importance}}
}
\author{
Maximilian Pichler
}
